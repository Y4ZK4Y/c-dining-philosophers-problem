
// challenges: starvation - synchronization - fair allocation of resources - deadlock prevention

// time tracking - synchronization - state management

// deadlock prevention algos: 1. resource hierarchy 2. odd/even
// starvation avoidance: fair queueing(scheduling system) queue philos based on turns
monitor states; to see who has been waiting the longest

// one thread per philo
// no global variable
// one fork per philo// 
// a mutex per fork and that it's used to check the fork value and/or change it.
// outputs should not mix up
// death of a philo should be verified
// there should be a mutex to prevent philo from dying and starting eating at the same time
// do not test with more tahn 200 philos
// to run the program:
// ./philo <num_philo> <time_die> <time_eat> <time_sleep>
// ints between 0 and int_max

// atomic variables?



// time each state
philo_life_cycle()
{
    while (sim not ended) // or while philo alive
    {
        think();
        pickup forks();
        eat();
        put_down_forks();
        sleep();    
    }
}

sim()
{
    create_threads;
    join threads;


}


init()
{
    init_philos();
    init_forks();
    init_logs();
}


wait for philos to finish or if somebody dies
main()
{
    parse();
    init();
    start similation();
    cleanup exit;
}


cleanup()
{
    destroy mutexes;
    free resources();
}


forks can be an array of mutexes
mutexes for logging


think()
{
    logging;

}


// watch out for deadlocks
// using a waiter algorithm where philos pick u p the lowered num fork first,e xcept for guy numebr 1 who picksup the higher numbered.

pick_up_forks()
{
    lock fork
    while fork not available
        wait
    unlock fork
}



put down forks()
{
    signal that its done and other can eat (monitor)
}


// request monitor for eating
eat()
{
    mark start of eating;
    wait for (time_to_eat)
    meal_count++
    last_meal update;
}

sleep()
{
    log;
    wait for time_to_sleep;
}


// only on thread can log at a time// use mutexes
logging()
{
    time_stamp
}


// a thread
monitor()
{
    while (sim ok)
    {
        check philos lastmeal time;
        if philo starved
            end sim;
    }

}


figure out the shared resources to specify the "critical section" of the program
logs - forks - philo satates?


typedef struct fork
whos holding the work
locked or unlocked


philos queue ? circular singly linked list? 
philosophers pick up forks in a consistant torder
if i use a doubly linked list for philosophers, does that violate the yjey shouldf not talk to each other rule ?


shared resources:
forks(mutexes)
states (an array)
should it be a struct??
typedef struct shared resources{

}; shared_resources
shared_resources shared;
for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
    pthread_mutex_init(&shared.forks[i], NULL);
}


int left_fork = philosopher_id;
int right_fork = (philosopher_id + 1) % NUM_PHILOSOPHERS;


philo_lifecycle();
get_time_ms();
eat();
sleep();
think();
pick_up_forks();
put_down_forks();



structs:

typedef struct s_info
{
    t_philo *philosophers;
    t_forks *forks;
    t_logging *logs;
    t_input *input;
    
    bool is_dead;

}   t_info;


enum philo_states{
    eating,
    thinking,
    sleeping,
    dead,
    hungry,
};


enum simulation_state {
    active,
    inactive,

};

typedef struct s_philo {
    int id; // 1 to num_philo
    long long last_meal_time;
    int num_meals;
    *left_fork;
    *right_fork;
    char *philos[];
    pthread_t thread;

    

} t_philo;

typedef struct s_input
{
    int num_of_philos;
    int time_to_die;
    int time_to_eat;
    int time_to_sleep; // long long

}   t_input;

typedef struct s_monitor
{
    does it need mutex?
    static_assertforks availability

}   t_monitor;




parse()
{

}
./philo 10 20 30 40


// enum simulation_state {
//     active,
//     inactive,

// };

// typedef struct s_monitor
// {
//     does it need mutex?
//     static_assertforks availability

// }   t_monitor;


*left_fork;
    *right_fork;
    char *philos[];







// void *func(void *arg)
// {
//     t_info *info = (t_info *)arg;

//     pthread_mutex_lock(&info->mutex);
//     printf("hello from func.\n");
//     pthread_mutex_unlock(&info->mutex);
//     pthread_mutex_unlock(&info->mutex);
//     usleep(100); // Sleep for a short time to avoid busy waiting
    

//     return NULL;
// }


// int main(int argc, char **argv)
// {
//     t_input input;
//     int i;
//     t_info info;


//     if (argc != 5)
//     {
//         printf("arg aint right\n");
//         return (1);
//     }

//     input = parse(argc, argv);
//     if (input.error == 1)
//     {
//         printf("parsing failed.\n");
//         return (1);
//     }
//     bzero(&info, sizeof(info));
//     pthread_t p[5];
//     pthread_mutex_init(&info.mutex, NULL);
//     for (i = 0; i < 5; i++)
//     {
//         pthread_create(&p[i], NULL, &func, &info);
//         printf("thread %d started: %p\n", i, p[i]);
//     }
//     for (i = 0; i < 5; i++)
//     {
//         pthread_join(p[i], NULL);
//         printf("thread %d joined: %p\n", i, p[i]);
//     }
//     pthread_mutex_destroy(&info.mutex);
//     return (0);

// }




output to stdout
error to stderr



----------------------------------------------------
new plan:

// monitor.c







// philo_life_cycle
philo_life_cycle()
{

}








// sim.c

wait_for_threads
{
    pthread join for every threads
}

create_threads
{
    create_thread for num_philo
    sim_on true
    get the start time
}


sim
{
    create_monitor;
    create_threads();
    wait_for_threads();
}





// init.c
init_mutexes()
{
    mutex init for forks (num_philos);
    init mutex for write_log;
}


init_philo
{
    for num of philos
        init the struct
        assign values
        malloc for thread
}


init_monitor()
{
    malloc for one monitor;
    init mutex turn lock;
    assign values;

}

init
{
    malloc for num of philos (5 people ie)
    init_philo(); //init struct for every philo
    init_mutexes();
    init_monitor();
}



// input.c
parse_input
{
    initialize input struct;
    ft_strtol argv into int;
    assign values;
}

get_input
{
    check num of args;
    parse input;
    if num_philo 0 or less
        exit;
}


// main.c
main
{
    get_input();
    philo_init();
    start_sim();
    exit_cleanup();
}